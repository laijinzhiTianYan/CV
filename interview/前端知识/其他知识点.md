- RPC远程过程调用
  ![](https://www.zhihu.com/question/25536695)
- 前端优化24条建议
  - 减少HTTP请求：真正下载数据的时间占比为 content download（谷歌可以看到） / 发送请求到数据下载完成的时间，文件越小，这个比例越小，文件越大，比例就越高。这就是为什么要建议将多个小文件合并为一个大文件，从而减少 HTTP 请求次数的原因。
  - 使用HTTP2：解析速度快，多路复用tcp链接，首部压缩，对比较紧急的请求设置一个较高的优先级，流量控制，服务器推送。
  - 使用服务器渲染
    - 客户端渲染: 获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，再渲染。
    - 服务端渲染：服务端返回 HTML 文件，客户端只需解析 HTML。
    优点：首屏渲染快，SEO 好。
    缺点：配置麻烦，增加了服务器的计算压力。
  - 静态资源使用CDN
    内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器，让用户离服务器更近，从而缩短请求时间。
    如果用户访问的网站部署了 CDN，过程是这样的：
    1. 浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。
    2. 本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到全局负载均衡系统（GSLB）的 IP 地址。
    3. 本地 DNS 再向 GSLB 发出请求，GSLB 的主要功能是根据本地 DNS 的 IP 地址判断用户的位置，筛选出距离用户较近的本地负载均衡系统（SLB），并将该 SLB 的 IP 地址作为结果返回给本地 DNS。
    4. 本地 DNS 将 SLB 的 IP 地址发回给浏览器，浏览器向 SLB 发出请求。
    5. SLB 根据浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器。
    6. 浏览器再根据 SLB 发回的地址重定向到缓存服务器。
    7. 如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器。如果没有，就向源服务器请求资源，再发给浏览器并缓存在本地。
  - 将 CSS 放在文件头部，JavaScript 文件放在底部
    所有放在 head 标签里的 CSS 和 JS 文件都会堵塞渲染。
    - 为什么 CSS 文件还要放在头部呢？
    因为先加载 HTML 再加载 CSS，会让用户第一时间看到的页面是没有样式的、“丑陋”的，为了避免这种情况发生，就要将 CSS 文件放在头部了。
    - JS 文件也不是不可以放在头部，只要给 script 标签加上 defer/async 属性就可以了，异步下载，延迟执行。
  -  使用字体图标 iconfont 代替图片图标
     - 将图标制作成一个字体，使用时就跟字体一样，可以设置属性，例如 font-size、color 等等
     - 字体图标是矢量图，不会失真
     - 文件特别小
- 善用缓存，不重复加载相同的资源：cache-control max-age(max-age 是一个相对时间,Expires 设置了一个时间，只要在这个时间之前,直接 使用缓存,但是客户端和服务器的时间不一定契合)，还有就是etag/if-sence-modified结合的协商缓存。
   - max-age: 设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。在这个时间前，浏览器读取文件不会发出新请求，而是直接使用缓存。
   - 指定 no-cache 表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。即每次请求的时候都会向服务器比对文件有没变化，如果没变化就使用缓存，有变化就使用新的文件。
   - 前端代码使用 webpack 打包，根据文件内容生成对应的文件名，每次重新打包时只有内容发生了变化，文件名才会发生变化。
  **大公司如何开发和部署前端代码**
  1. 利用304，让浏览器使用本地缓存。但是还要和服务器通信一次。
  2. 强制浏览器使用本地缓存（cache-control/expires），不要和服务器通信。但是缓存如何更新？
  3. 通过让url的修改与文件内容关联，也就是说，只有文件内容变化，才会导致相应url的变更，从而实现文件级别的精确缓存控制。
     利用 <u>数据摘要算法</u>，对文件求摘要信息，摘要信息与文件内容一一对应.
  4. 为了进一步提升网站性能，会把静态资源和动态网页分集群部署，静态资源会被部署到CDN节点上，网页中引用的资源也会变成对应的部署路径。如果改变了静态资源，那么静态资源的url也会改变，html中的引用也会更改，现在要发布代码上线，先上线页面or先上线静态资源？
     - 先部署页面，再部署资源：在二者部署的时间间隔内，如果有用户访问页面，就会在新的页面结构中加载旧的资源，并且把这个旧版本的资源当做新版本缓存起来，其结果就是：用户访问到了一个样式错乱的页面，除非手动刷新，否则在资源缓存过期之前，页面会一直执行错误。
     - 先部署资源，再部署页面：在部署时间间隔之内，有旧版本资源本地缓存的用户访问网站，由于请求的页面是旧版本的，资源引用没有改变，浏览器将直接使用本地缓存，这种情况下页面展现正常；但没有本地缓存或者缓存过期的用户访问网站，就会出现旧版本页面加载新版本资源的情况，导致页面执行错误，但当页面完成部署，这部分用户再次访问页面又会恢复正常了。
  5. 上述问题起源于资源的覆盖式发布，用 待发布资源 覆盖 已发布资源。解决：实现非覆盖式发布。内容有修改的资源（用文件的摘要信息来对资源文件进行命名）变成一个新的文件发布到线上，不会覆盖已有的资源文件。上线过程中，先全量部署静态资源，再灰度部署页面，整个问题就比较完美的解决了。
- 压缩文件
  1、在 webpack 可以使用如下插件进行压缩：
  JavaScript：UglifyPlugin
  CSS ：MiniCssExtractPlugin
  HTML：HtmlWebpackPlugin
  2、gzip 是目前最流行和最有效的压缩方法。webpack 和 node 可以配置 gzip 。
- 图片优化
  1. 图片延迟加载：在页面中，先不给图片设置路径，只有当图片出现在浏览器的可视区域时，才去加载真正的图片，这就是延迟加载。
   首先将图片这样设置，在页面不可见时图片不会加载：<img data-src="https://avatars0.githubusercontent.com/u/22117876?s=460&u=7bd8f32788df6988833da6bd155c3cfbebc68006&v=4">
   等页面可见时，使用 JS 加载图片：
   ```
   const img = document.querySelector('img')
   if(isShow(img)){
     img.src = img.getAttribute('data-src');
   }
  function isShow(ele){
    let e=ele.getBoundingClientRect();
    return (e.top<=window.innerHeight||document.documentElement.clientHeight);
    //或者
    var total = document.body.offsetHeight;//首先获得屏幕可用高度：
    return (ele.scrollTop+total>e.top)
  }
   ```
  2. 响应式图片：浏览器能够根据屏幕大小自动加载合适的图片。通过<picture>或者@media的min-width和max-width实现。
  3. 调整图片大小：一开始，只加载缩略图，当用户悬停在图片上时，才加载大图。
  4. 降低图片质量：例如 JPG 格式的图片，100% 的质量和 90% 质量的通常看不出来区别，尤其是用来当背景图的时候。
  5. 尽可能利用 CSS3 效果代替图片：很多图片使用 CSS 效果（渐变、阴影等）就能画出来，而代码大小通常是图片的几分之一甚至几十分之一。
  
-  通过 webpack(import) 按需加载代码，提取第三库代码，减少 ES6 转为 ES5 的冗余代码
-  减少重绘重排
  **PS：**JavaScript 引擎线程与 GUI 渲染线程是互斥，它们同时只能一个在工作。
  重排：添加或删除可见的 DOM 元素/元素位置改变/元素尺寸改变/内容改变/浏览器窗口尺寸改变
  减少重排重绘：
    1. 用 JavaScript 修改样式时，最好不要直接写样式，而是替换 class 来改变样式。
    2. 如果要对 DOM 元素执行一系列操作，可以将 DOM 元素脱离文档流，修改完成后，再将它带回文档。推荐使用隐藏元素（display:none）或文档碎片（DocumentFragement），都能很好的实现这个方案。
- 使用事件委托
  ```
  document.querySelector('ul').onclick = (event) => {
  const target = event.target
  if (target.nodeName === 'LI') {
    console.log(target.innerHTML)
    }
  }
  ```
- 注意程序的局部性
- 当判断条件数量越来越多时，越倾向于使用 switch 而不是 if-else。
- 避免页面卡顿
- 使用 requestAnimationFrame 来实现视觉变化
  **为了尽量避免动画卡顿，最好的情况就是每次代码都是在帧的开头开始执行，保证 JavaScript 在帧开始时运行的唯一方式是使用 requestAnimationFrame**
- 使用 Web Workers，Web Worker 适用于那些处理纯数据，或者与浏览器 UI 无关的长时间运行脚本。
  Web Worker 使用其他工作线程从而独立于主线程之外，它可以执行任务而不干扰用户界面。一个 worker 可以将消息发送到创建它的 JavaScript 代码, 通过将消息发送到该代码指定的事件处理程序
  **PS:js主线程是单线程的，依靠事件循环机制实现异步，底层还是有其他线程的**
- 使用位操作：位操作比其他数学运算和布尔操作快得多。
- 不要覆盖原生方法
  无论你的 JavaScript 代码如何优化，都比不上原生方法。因为原生方法是用低级语言写的（C/C++），并且被编译成机器码，成为浏览器的一部分。当原生方法可用时，尽量使用它们，特别是数学运算和 DOM 操作。 
-  降低 CSS 选择器的复杂性
  1. 浏览器读取选择器，遵循的原则是从选择器的右边到左边读取
  2. CSS 选择器优先级:!important > 内联 > ID选择器 > 类选择器 > 标签选择器
所以，选择器越短越好；尽量使用高优先级的选择器，例如 ID 和类选择器；避免使用通配符 *。
-  使用flex
-  使用 transform 和 opacity 属性更改来实现动画
  **在 CSS 中，transforms 和 opacity 这两个属性更改不会触发重排与重绘，它们是可以由合成器（composite）单独处理的属性。**
- 合理使用规则，避免过度优化
  性能优化主要分为两类：加载时优化（前十条）；运行时优化（后13条）
  - 检查加载性能：一个网站加载性能如何主要看白屏时间和首屏时间。
    - 白屏时间：指从输入网址，到页面开始显示内容的时间。在head中，
      ```
      <script>
	      new Date() - performance.timing.navigationStart
      </script>
      ```
    - 首屏时间：指从输入网址，到页面完全渲染的时间。
       首屏时间比较复杂，得考虑有图片和没有图片的情况。
       - 如果没有图片，则在 window.onload 事件里执行 new Date() - performance.timing.navigationStart 即可获取首屏时间。
          <u>window.onload是一个事件，在文档加载完成后能立即触发，并且能够为该事件注册事件处理函数</u>。将要对对象或者模块进行操作的代码存放在处理函数中。即：window.onload =function (){这里写操作的代码};
       - 如果有图片，则要在最后一个在首屏渲染的图片的 onload 事件里执行 new Date() - performance.timing.navigationStart 获取首屏时间，实施起来比较复杂
  - 检查运行性能
    配合 chrome 的开发者工具，我们可以查看网站在运行时的性能。  


