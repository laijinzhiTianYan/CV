- 1、 首屏性能指标  performance

- 白屏时间：白屏时间是指浏览器从响应用户输入网址地址，到浏览器开始渲染内容的时间。
- 首屏时间：首屏时间是指浏览器从响应用户输入网络地址，到首屏内容渲染完成的时间。 一般是首屏中的图片加载完毕的时候，我们认为是首屏结束的时间点。
- 完全加载时间：DOM Tree 构建完成后，开始加载网页资源，资源完全加载完成后，从加载开始到此为网页的完全加载时间。
- 可交互时间 (TTI)：用户第一次可以和界面进行交互的时间
- 慢会话 Long Tasks：RAIL有在100毫秒内相应用户输入的要求。如果响应超过这个时间就是慢会话


- 2、 首屏优化策略：
  - Vue-Router路由懒加载（利用Webpack的代码切割）
  - 使用CDN加速，将通用的库从vendor进行抽离
  - Nginx的gzip压缩
  - Vue异步组件
    >1、
    Vue.component(
      'async-webpack-example',
      // 这个动态导入会返回一个 `Promise` 对象。
      () => import('./my-async-component')
    )  
    2、new Vue({
       components: {  
        'my-component': () => import('./my-async-component')  
       }  
    })
    
  - 服务端渲染SSR
    >将组件或页面通过服务器生成html字符串，再发送到浏览器，最后将静态标记"混合"为客户端上完全交互的应用程序  
    
    >**SSR的局限**     
        
         - 服务端压力较大
        本来是通过客户端完成渲染，现在统一到服务端node服务去做。尤其是高并发访问的情况，会大量占用服务端CPU资源；

        - 开发条件受限
        在服务端渲染中，只会执行到componentDidMount之前的生命周期钩子，因此项目引用的第三方的库也不可用其它生命周期钩子，这对引用库的选择产生了很大的限制；

        - 学习成本相对较高
        除了对webpack、React要熟悉，还需要掌握node、Koa2等相关技术。相对于客户端渲染，项目构建、部署过程更加复杂


  - 如果使用了一些UI库，采用按需加载
  - Webpack开启gzip压缩
  - 如果首屏为登录页，可以做成多入口
  - Service Worker缓存文件处理
  - 使用link标签的rel属性设置 prefetch（这段资源将会在未来某个导航或者功能要用到，但是本资源的下载顺序权重比较低，prefetch通常用于加速下一次导航）、preload（preload将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度）
  - 拆分页面：首先加载关键模块、非关键模块放入lazyQueue，在onload再加载；懒执行（交互执行），tab模块在hover或click的时候再执行；更懒的执行，一些非关键的信息在第一访问请求，并缓存，在第二次访问的时候才显示。
