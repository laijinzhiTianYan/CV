- 放在 </head> 前面就能获取白屏时间。
  ```
  <script>
     // 同一个浏览器上一个页面卸载(unload)结束时的时间戳。如果没有上一个页面，这个值会和fetchStart相同
      whiteScreen = new Date() - performance.timing.navigationStart
  </script>
  ```

- HOST ORIGIN REFERER
  - Host
   表示当前请求要被发送的目的地，说白了就是当前请求目标资源的host，仅包括域名和端口号，如test.haoji.me。在任何类型请求中，request都会包含此header信息。
  - Origin
   表示当前请求资源所在页面的协议和域名，如http://blog.haoji.me，不包含路径等信息，也就不会包含含有用户信息的敏感内容。特别注意：
   这个参数一般只存在于CORS跨域请求中，普通请求没有这个header！（有人说它只存在于post请求中）
  - Referer
   表示当前请求资源所在页面的完整路径：协议+域名+查询参数（注意不包含锚点信息），如http://blog.haoji.me/http-host-origin-referer.html?a=1&b=2，所有类型的请求都包含此header。
   因为原始的URI中的查询参数可能包含ID或密码等敏感信息，如果写入referer，则可能导致信息泄露。
   *为了安全计，新的Referrer规定了五种策略：*
    - No Referrer：任何情况下都不发送Referrer信息
    - No Referrer When Downgrade：仅当协议降级（如HTTPS页面引入HTTP资源）时不发送Referrer信息。是大部分浏览器默认策略。
    - Origin Only：发送只包含host部分的referrer.
    - Origin When Cross-origin：仅在发生跨域访问时发送只包含host的Referer，同域下还是完整的。与Origin Only的区别是多判断了是否是Cross-origin。协议、域名和端口都一致，浏览器才认为是同域。
    - Unsafe URL：全部都发送Referrer信息。最宽松最不安全的策略。
- HTTPS SSL证书加密原理,其工作于传输层和应用层之间。
  ![https](https://img2020.cnblogs.com/blog/1395105/202005/1395105-20200526213357731-2033948230.jpg)
    1. 客户端向服务器发起请求（Client Hello）。
        客户端主要向服务器提供以下信息。
        （1） 支持的协议版本，比如TLS 1.0版。
        （2） 一个客户端生成的随机数，稍后用于生成"对话密钥"。
        （3） 支持的加密方法，比如RSA公钥加密。
        （4） 支持的压缩方法。
    2. 服务器回应客户端的请求（Server Hello），并且返回数字证书。
        服务器的回应包含以下内容。
        （1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
        （2） 一个服务器生成的随机数，稍后用于生成"对话密钥"。
        （3） 确认使用的加密方法，比如RSA公钥加密。
        （4） 服务器证书。
    3. 客户端的浏览器进入数字证书认证环节，这一部分是浏览器内置的TLS完成的。
        （1）首先浏览器从内置的证书列表中索引，找到服务器下发证书对应的机构，取出该机构颁发的公钥。没有找到则不可信任。
        （2）用机构的证书公钥解密得到证书的内容和签名（内容包括网站的网址，网站的公钥等）。
        （3）浏览器生成一个随机数R，并使用网站公钥对R进行加密。
          然后向服务器发送下面三项信息：
        （1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。
        （2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
        （3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。

    4. 服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的"会话密钥"。然后，向客户端最后发送下面信息。
        （1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
        （2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验
        至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用"会话密钥"加密内容。
    5. 服务器以R为密钥使用了对称加密算法加密网页内容并传输给浏览器。
    6. 浏览器以R为密钥使用之前约定好的解密算法获取网页内容。

    - 不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险：
    （1） 窃听风险（eavesdropping）：第三方可以获知通信内容。
    （2） 篡改风险（tampering）：第三方可以修改通信内容。
    （3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。

    - SSL/TLS协议是为了解决这三大风险而设计的，希望达到：
    （1） 所有信息都是加密传播，第三方无法窃听。
    （2） 具有校验机制，一旦被篡改，通信双方会立刻发现。
    （3） 配备身份证书，防止身份被冒充。

    SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。
    但是，这里有两个问题。
    - （1）如何保证公钥不被篡改？
    解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。
    - （2）公钥加密计算量太大，如何减少耗用的时间？
    解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。
      **根据上面的过程，用三个随机数生成“会话密钥”的原因**
      简单来说，就是三个伪随机接近随机。


    因此，SSL/TLS协议的基本过程是这样的：
    （1） 客户端向服务器端索要并验证公钥。
    （2） 双方协商生成"对话密钥"。
    （3） 双方采用"对话密钥"进行加密通信。


