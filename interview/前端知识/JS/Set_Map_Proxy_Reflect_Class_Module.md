## Set——`const set = new Set(arr)`
- 属性
  >constructor：构造函数，返回Set
  size：返回实例成员总数
- 方法
  >add()：添加值，返回实例
  delete()：删除值，返回布尔
  has()：检查值，返回布尔
  clear()：清除所有成员
  keys()：返回以属性值为遍历器的对象
  values()：返回以属性值为遍历器的对象
  entries()：返回以属性值和属性值为遍历器的对象
  forEach()：使用回调函数遍历每个成员
- 应用
  去重字符串：[...new Set(str)].join("")
  去重数组：[...new Set(arr)]或Array.from(new Set(arr))
  集合数组：
    - 声明：const a = new Set(arr1)、const b = new Set(arr2)
    - 并集：new Set([...a, ...b])
    - 交集：new Set([...a].filter(v => b.has(v)))
    - 差集：new Set([...a].filter(v => !b.has(v)))
  映射集合：
    - 声明：let set = new Set(arr)
    - 映射：set = new Set([...set].map(v => v * 2))或set = new Set(Array.from(set, v => v * 2)
- 重点:
  - 没有键只有值，可认为键和值两值相等
  - **添加多个NaN时，只会存在一个NaN(结合数组去重去看)**
  - **添加相同的对象时，会认为是不同的对象(结合数组去重去看)**
  - **添加值时不会发生类型转换(5 !== "5")**
  - keys()和values()的行为完全一致，entries()返回的遍历器同时包括键和值且两值相等

- ### WeakSet：和Set结构类似，成员值只能是对象
  constructor：构造函数，返回WeakSet
  add()：添加值，返回实例
  delete()：删除值，返回布尔
  has()：检查值，返回布尔
    - **重点**
      - 成员都是弱引用，垃圾回收机制不考虑WeakSet结构对此成员的引用
      - 成员不适合引用，它会随时消失，因此ES6规定WeakSet结构不可遍历
      - 其他对象不再引用成员时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于WeakSet结构中
    - **应用**
      - 储存DOM节点：DOM节点被移除时自动释放此成员，不用担心这些节点从文档移除时会引发内存泄漏
      - 临时存放一组对象或存放跟对象绑定的信息：只要这些对象在外部消失，它在WeakSet结构中的引用就会消失

----------

## Map:类似于对象的数据结构，成员键是任何类型的值.`const set = new Map(arr)`
- 属性
   >constructor：构造函数，返回Map
   size：返回实例成员总数
- 方法
  >get()：返回键值对
  set()：添加键值对，返回实例
  delete()：删除键值对，返回布尔
  has()：检查键值对，返回布尔
  clear()：清除所有成员
  keys()：返回以键为遍历器的对象
  values()：返回以值为遍历器的对象
  entries()：返回以键和值为遍历器的对象
  forEach()：使用回调函数遍历每个成员
- 重点
  - 对同一个键多次赋值，后面的值将覆盖前面的值
  - 对同一个对象的引用，被视为一个键
  - 对同样值的两个实例，被视为两个键（new String('1'),new String('1')无法去重，/a/与/a/也不行）
  - 键跟内存地址绑定，只要内存地址不一样就视为两个键（同上去重问题）
  - 添加多个以NaN作为键时，只会存在一个以NaN作为键的值（说明可以为NaN去重）
  - Object结构提供字符串—值的对应，Map结构提供值—值的对应

- ### WeakMap：和Map结构类似，成员键只能是对象
    constructor：构造函数，返回WeakMap
    get()：返回键值对
    set()：添加键值对，返回实例
    delete()：删除键值对，返回布尔
    has()：检查键值对，返回布尔
    - 重点
      - <u>成员键都是弱引用，</u>垃圾回收机制不考虑WeakMap结构对此成员键的引用
      - 成员键不适合引用，它会随时消失，因此ES6规定WeakMap结构不可遍历
      - 其他对象不再引用成员键时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于WeakMap结构中
      - 一旦不再需要，成员会自动消失，不用手动删除引用
      - 弱引用的只是键而不是值，值依然是正常引用
      - 即使在外部消除了成员键的引用，内部的成员值依然存在
    - 应用
      - 储存DOM节点：DOM节点被移除时自动释放此成员键，不用担心这些节点从文档移除时会引发内存泄漏
      - 部署私有属性：内部属性是实例的弱引用，删除实例时它们也随之消失，不会造成内存泄漏

---------

## Proxy:修改某些操作的默认行为 `const proxy = new Proxy(target, handler)`
- 入参
    >target：拦截的目标对象
    >handler：定制拦截行为


Reflect 和 Class

-------

## Module
  >CommonJS：用于服务器(动态化依赖)
  AMD：用于浏览器(动态化依赖)
  CMD：用于浏览器(动态化依赖)
  UMD：用于浏览器和服务器(动态化依赖)
  ESM：用于浏览器和服务器(静态化依赖)
  
  - 运行时加载
  定义：整体加载模块生成一个对象，再从对象上获取需要的属性和方法进行加载(全部加载)
  影响：只有运行时才能得到这个对象，导致无法在编译时做静态优化
  - 编译时加载
  定义：直接从模块中获取需要的属性和方法进行加载(按需加载)
  影响：在编译时就完成模块加载，效率比其他方案高，但无法引用模块本身(本身不是对象)，可拓展JS高级语法(宏和类型校验)
  
  - 传统加载：通过<script>进行同步或异步加载脚本 
    - 同步加载：<script src=""></script>
    - Defer异步加载：<script src="" defer></script>(顺序加载，渲染完再执行)
    - Async异步加载：<script src="" async></script>(乱序加载，下载完就执行)
  - 模块加载：<script type="module" src=""></script>(默认是Defer异步加载)





