### 动态规划

![](https://pic.leetcode-cn.com/1f95da43d1bdeebdd1213bb804034ddc5f906dc61451cd63f2b5ab5d0eb33b33-%E3%80%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%8D%E9%97%AE%E9%A2%98%E6%80%9D%E8%80%83%E6%96%B9%E5%90%91.png '动态规划思维导图')

*状态的定义，先尝试「题目问什么，就把什么设置为状态* 

最大回文子串的题目，设置状态为子串是否为回文，是为true，否为false。

dp[i][j]:表示从第i个位置开始，到第j个位置满足了什么状态。
比如回文：
- dp[i][j] 表示子串 s[i..j] 是否为回文子串，这里子串 s[i..j] 定义为左闭右闭区间，可以取到 s[i] 和 s[j]。
- 状态转移方程：dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]
- 考虑初始化：初始化的时候，单个字符一定是回文串，因此把对角线先初始化为 true，即 dp[i][i] = true 。
事实上，初始化的部分都可以省去。因为只有一个字符的时候一定是回文，dp[i][i] 根本不会被其它状态值所参考。
- 考虑输出：只要一得到 dp[i][j] = true，就记录子串的长度和起始位置，没有必要截取，这是因为截取字符串也要消耗性能，记录此时的回文子串的「起始位置」和「回文长度」即可。

以字符串babad为例：对角线首先初始化,bab和aba均可，如果要求全部输出，可以
if(dp[i][j]&&j-i+1>（=）maxlength){
    maxlength=j-i+1;
    begin=i;
    保存s.substring(begin,begin+maxlength);
}

|    l\r    |  0     |     1     |      2     |     3     |    4    |
|:---------:|:-------| ---------:| ----------:| ---------:| -------:|
|   0       |   true | false(1)  |    true(2) |  false(4) |false(7) |
|   1       |        |   true    |   false(3) |   true(5) |false(8) |
|   2       |        |           |    true    |  false(6) |false(9) |
|   3       |        |           |            |   true    |false(10)|
|   4       |        |           |            |           |    true |