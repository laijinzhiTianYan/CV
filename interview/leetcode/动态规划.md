### 动态规划

![](https://pic.leetcode-cn.com/1f95da43d1bdeebdd1213bb804034ddc5f906dc61451cd63f2b5ab5d0eb33b33-%E3%80%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%8D%E9%97%AE%E9%A2%98%E6%80%9D%E8%80%83%E6%96%B9%E5%90%91.png '动态规划思维导图')

*状态的定义，先尝试「题目问什么，就把什么设置为状态* 

最大回文子串的题目，设置状态为子串是否为回文，是为true，否为false。

dp[i][j]:表示从第i个位置开始，到第j个位置满足了什么状态。
比如回文：
- dp[i][j] 表示子串 s[i..j] 是否为回文子串，这里子串 s[i..j] 定义为左闭右闭区间，可以取到 s[i] 和 s[j]。
- 状态转移方程：dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]
- 考虑初始化：初始化的时候，单个字符一定是回文串，因此把对角线先初始化为 true，即 dp[i][i] = true 。
事实上，初始化的部分都可以省去。因为只有一个字符的时候一定是回文，dp[i][i] 根本不会被其它状态值所参考。
- 考虑输出：只要一得到 dp[i][j] = true，就记录子串的长度和起始位置，没有必要截取，这是因为截取字符串也要消耗性能，记录此时的回文子串的「起始位置」和「回文长度」即可。

以字符串babad为例：对角线首先初始化,bab和aba均可，如果要求全部输出，可以
if(dp[i][j]&&j-i+1>（=）maxlength){
    maxlength=j-i+1;
    begin=i;
    保存s.substring(begin,begin+maxlength);
}

|    l\r    |  0     |     1     |      2     |     3     |    4    |
|:---------:|:-------| ---------:| ----------:| ---------:| -------:|
|   0       |   true | false(1)  |    true(2) |  false(4) |false(7) |
|   1       |        |   true    |   false(3) |   true(5) |false(8) |
|   2       |        |           |    true    |  false(6) |false(9) |
|   3       |        |           |            |   true    |false(10)|
|   4       |        |           |            |           |    true |


**leetcode96 不同的二叉搜索树：给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？**

方法1：动态规划
**思路**

给定一个有序序列 1⋯n，为了构建出一棵二叉搜索树，我们可以遍历每个数字 i，将该数字作为树根，将1⋯(i−1) 序列作为左子树，将(i+1)⋯n 序列作为右子树。接着我们可以按照同样的方式递归构建左子树和右子树。

在上述构建的过程中，由于根的值不同，因此我们能保证每棵二叉搜索树是唯一的。

由此可见，原问题可以分解成规模较小的两个子问题，且子问题的解可以复用。因此，我们可以想到使用动态规划来求解本题

定义两个函数：
G(n): 长度为 n 的序列能构成的不同二叉搜索树的个数。

F(i, n): 以 i 为根、序列长度为 n 的不同二叉搜索树个数(1≤i≤n)。
**注意到 G(n) 和序列的内容无关，只和序列的长度有关.**
设i=3，n=7:F(3,7)=G(2)⋅G(4)，泛化得到：F(i,n)=G(i−1)⋅G(n−i)

```
var numTrees = function(n) {
    const G = new Array(n + 1).fill(0);
    G[0] = 1;
    G[1] = 1;

    for (let i = 2; i <= n; ++i) {
        for (let j = 1; j <= i; ++j) {
            G[i] += G[j - 1] * G[i - j];
        }
    }
    return G[n];
};
```
```
class Solution {
    public int numTrees(int n) {
        int[] G = new int[n + 1];
        G[0] = 1;
        G[1] = 1;

        for (int i = 2; i <= n; ++i) {
            for (int j = 1; j <= i; ++j) {
                G[i] += G[j - 1] * G[i - j];
            }
        }
        return G[n];
    }
}
```

***复杂度分析***

- 时间复杂度 : O(n^2),其中 n表示二叉搜索树的节点个数。G(n) 函数一共有 n 个值需要求解，每次求解需要 O(n) 的时间复杂度，因此总时间复杂度为 O(n^2).
- 空间复杂度 : O(n)。我们需要 O(n) 的空间存储 G数组。
**其实，G(n)函数的值在数学上被称为卡塔兰数Cn**
​卡塔兰数更便于计算的定义如下:
C0=1,Cn+1= [2(2n+1)/(n+2)]*Cn
​```
var numTrees = function(n) {
    let C = 1;
    for (let i = 0; i < n; ++i) {
        C = C * 2 * (2 * i + 1) / (i + 2);
    }
    return C;
};
```

***复杂度分析***
- 时间复杂度 : O(n)，其中 n 表示二叉搜索树的节点个数。我们只需要循环遍历一次即可。
- 空间复杂度 : O(1)。我们只需要常数空间存放若干变量
