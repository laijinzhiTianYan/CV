## 事件循环：主线程从"任务队列"中读取执行事件，这个过程是循环不断的。

JavaScript的运行机制:

    （1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
    
    （2）主线程之外，还存在"任务队列"(task queue)。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
    
    （3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，就结束等待状态，进入执行栈，开始执行。
    
    （4）主线程不断重复上面的第三步

**一个事件循环中有一个或者是多个任务队列**

JavaScript中有两种异步任务:
- 宏任务: script（整体代码）, setTimeout, setInterval, setImmediate, I/O, UI rendering
- 微任务: process.nextTick（Nodejs）, Promises, Object.observe, MutationObserver;
-------

**过程如下：**
主线程会不断从任务队列中按顺序取任务执行，<u>每执行完一个任务</u>都会检查microtask队列是否为空（执行完一个任务的具体标志是函数执行栈为空），如果不为空则会一次性执行完所有microtask。然后再进入下一个循环去任务队列中取下一个任务执行。

**详细说明:**
- 选择当前要执行的宏任务队列，选择一个最先进入任务队列的宏任务，如果没有宏任务可以选择，则会跳转至microtask的执行步骤。
- 将事件循环的当前运行宏任务设置为已选择的宏任务。
- 运行宏任务。
- 将事件循环的当前运行任务设置为null。
- 将运行完的宏任务从宏任务队列中移除。
- microtasks步骤：进入microtask检查点。
- 更新界面渲染。
- 返回第一步。

**执行进入microtask检查的的具体步骤如下:**
- 设置进入microtask检查点的标志为true。
- 当事件循环的微任务队列不为空时：选择一个最先进入microtask队列的microtask；设置事件循环的当前运行任务为已选择的microtask；运行microtask；设置事件循环的当前运行任务为null；将运行结束的microtask从microtask队列中移除。
- 对于相应事件循环的每个环境设置对象（environment settings object）,通知它们哪些promise为rejected。
- 清理indexedDB的事务。
- 设置进入microtask检查点的标志为false。

**需要注意的是:当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件, 然后再去宏任务队列中取出一个事件。同一次事件循环中, 微任务永远在宏任务之前执行。**

---------
### 从setTimeout/setInterval看JS线程
一个异步过程通常是这样的：主线程发起一个异步请求，相应的工作线程（比如浏览器的其他线程）接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，通知主线程；主线程收到通知后，执行一定的动作(调用回调函数)。
**异步过程的通信机制：工作线程将消息放到消息队列（任务队列），主线程通过事件循环过程去取消息。**
工作线程是生产者，主线程是消费者。工作线程执行异步任务，执行完成后把对应的回调函数封装成一条消息放到消息队列中；主线程不断地从消息队列中取消息并执行，当消息队列空时主线程阻塞，直到消息队列再次非空。

-------
setTimeout(function, 0)，0不代表立即执行，而是将任务推到消息队列的最后，再由主线程的事件循环去调用它执行。
所以
>>定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，取决于何时被主线程的事件循环取到，并执行。

<u>HTML5 中规定setTimeout 的最小时间不是0ms，而是4ms。</u>

------

**一般认为setInterval有两个缺点：**

- 使用setInterval时，某些间隔会被跳过；
- 可能多个定时器会连续执行；

**链式setTimeout实现setInterval功能：**
```
setTimeout(function () {
    // 任务
    setTimeout(arguments.callee, interval);
}, interval)
函数每次执行的时候都会创建一个新的定时器，第二个setTimeout使用了arguments.callee()获取当前函数的引用，并且为其设置另一个定时器。
好处：
- 在前一个定时器执行完前，不会向队列插入新的定时器（解决缺点一）
- 保证定时器间隔（解决缺点二）
```
